Manual de Engenharia WUZAPI Manager: Padrões Arquiteturais e Diretrizes de Implementação State-of-the-Art1. Visão Geral Executiva e Filosofia Arquitetural1.1 Propósito e Escopo do DocumentoEste relatório técnico constitui a referência definitiva para a engenharia de software do projeto WUZAPI Manager. O documento foi elaborado para transcender a função de um simples guia de estilo, estabelecendo-se como um manual normativo que define a arquitetura, a organização estrutural e os protocolos operacionais necessários para o desenvolvimento de uma aplicação de nível empresarial. O stack tecnológico definido — React/TypeScript, Node.js/Express, SQLite e Docker Swarm — apresenta um conjunto único de vantagens e desafios que exigem uma abordagem arquitetural rigorosa, afastando-se de convenções genéricas em favor de padrões otimizados para performance local e manutenibilidade a longo prazo.A análise aprofundada das tendências de engenharia de software para 2024 e 2025 indica um movimento pendular que se afasta da complexidade dos microsserviços distribuídos em favor de arquiteturas monolíticas modulares bem estruturadas, especialmente para sistemas de gestão onde a consistência de dados e a simplicidade operacional superam a necessidade de escalabilidade elástica infinita.1 Este manual codifica essa filosofia, fornecendo aos novos desenvolvedores não apenas o "como" implementar, mas o "porquê" de cada decisão técnica, garantindo que o WUZAPI Manager permaneça robusto, seguro e evolutivo.1.2 Princípios Fundamentais de EngenhariaA fundação do WUZAPI Manager repousa sobre quatro pilares arquiteturais que devem guiar cada linha de código escrita pela equipe:Modularidade por Domínio (Modular Monolith): Rejeitamos a organização tradicional por camadas técnicas (Controllers, Services, Models globais) em favor do agrupamento por contexto de negócio (Features/Modules). A coesão funcional deve ter prioridade sobre a taxonomia técnica. O código que muda junto deve permanecer junto.1Explicitude sobre Implicitude: "Mágica" é proibida. O fluxo de dados, a injeção de dependências e o gerenciamento de estado devem ser rastreáveis estaticamente. Preferimos a instanciação explícita de serviços e a tipagem estrita a contêineres de injeção de dependência opacos ou "auto-wiring" que dificultam a depuração.4Durabilidade Local (Local-First Persistence): Dada a escolha do SQLite como motor de persistência, a arquitetura deve respeitar as leis da física do sistema de arquivos. A aplicação deve ser desenhada assumindo que o banco de dados é um recurso local de alto desempenho, exigindo estratégias específicas de pinning em orquestradores como o Docker Swarm para garantir a integridade dos dados.6Segurança Tipo-Orientada (Type-Driven Security): O TypeScript não é apenas um linter glorificado; é o nosso contrato de integridade. Utilizamos o modo estrito (strict: true) sem exceções e geramos contratos de API (OpenAPI) automaticamente a partir do código para garantir que o frontend e o backend falem exatamente a mesma língua, eliminando erros de integração em tempo de execução.82. Arquitetura de Backend: O Monólito ModularA arquitetura de backend do WUZAPI Manager adota o padrão Modular Monolith (Monólito Modular). Embora o ecossistema Node.js tradicionalmente promova uma arquitetura em camadas (Layered Architecture), a pesquisa indica que essa abordagem frequentemente devolve para o anti-padrão "Big Ball of Mud" à medida que o projeto cresce, onde as dependências entre domínios se tornam um espaguete indestricável. O Monólito Modular oferece o equilíbrio ideal: a simplicidade de implantação de um monólito com o isolamento de domínio dos microsserviços.2.1 Estrutura de Diretórios e OrganizaçãoA estrutura de pastas reflete a separação clara entre a fundação técnica ("o que faz a aplicação rodar") e a lógica de negócio ("o que a aplicação faz"). A raiz do projeto backend (src/) é bifurcada nessas duas diretrizes principais.A estrutura de pastas recomendada, baseada nas práticas "Bulletproof Node.js" e adaptada para 2025, é apresentada na tabela abaixo para clareza visual e referência rápida:DiretórioResponsabilidadeConteúdo Típicosrc/app.tsPonto de entradaConfiguração do Express, middlewares globais, tratamento de erros centralizado.src/server.tsInicializaçãoInicialização do servidor HTTP, gestão de portas e conexão inicial com o BD.src/config/ConfiguraçãoVariáveis de ambiente validade (e.g., envalid), constantes globais.src/shared/Kernel TécnicoCódigo agnóstico ao negócio: abstrações de BD, Loggers, Classes Base, Utilitários.src/modules/Núcleo de NegócioMódulos independentes (e.g., instances, messages, contacts).tests/QATestes de integração e E2E que atravessam múltiplos módulos.2.1.1 Anatomia de um Módulo (src/modules/)Cada pasta dentro de src/modules/ deve ser tratada como uma "mini-aplicação" isolada. O objetivo é que um desenvolvedor trabalhando no módulo de "Instâncias do WhatsApp" raramente precise sair do diretório src/modules/instances/. Essa estrutura promove a alta coesão e facilita uma eventual extração para microsserviços, caso a escala exija no futuro.10Estrutura Interna de um Módulo:Plaintextsrc/modules/instances/
├── api/                       # Camada de Interface (Entrada)
│   ├── http/
│   │   ├── instances.controller.ts # Manipulação de Request/Response
│   │   └── instances.router.ts     # Definição de Rotas Express
│   └── dtos/                  # Data Transfer Objects (Validação Zod/Joi)
├── core/                      # Camada de Aplicação e Domínio
│   ├── services/              # Casos de uso e orquestração
│   ├── domain/                # Entidades e Tipos do Domínio
│   └── errors/                # Erros específicos do módulo
├── infra/                     # Camada de Infraestrutura (Saída)
│   ├── repositories/          # Implementação do acesso ao SQLite
│   └── mappers/               # Conversão Linha BD <-> Entidade Domínio
└── index.ts                   # API Pública do Módulo
A Regra da API Pública (index.ts):O arquivo index.ts na raiz de cada módulo atua como uma barreira arquitetural (Facade). Outros módulos (ex: messages) nunca devem importar arquivos internos de instances (como instances/infra/repo.ts). Eles devem importar apenas o que é exportado explicitamente pelo instances/index.ts. Isso previne o acoplamento oculto e permite refatorações internas seguras.2.2 Padrões de Design e ResponsabilidadesA implementação interna dos módulos segue uma adaptação da Clean Architecture, simplificada para o contexto de Node.js/TypeScript.122.2.1 A Camada de Controle (api/)A responsabilidade única do Controller é a tradução. Ele traduz o protocolo HTTP (requests, headers, body) para a linguagem do domínio (DTOs) e traduz o resultado do domínio de volta para HTTP (status codes, JSON).Diretriz: Controllers não devem conter lógica de negócio. Eles apenas validam a entrada (usando bibliotecas como Zod) e delegam a execução para a camada de serviço.Prática State-of-the-Art: Uso de decoradores ou wrappers de rota para padronizar o tratamento de exceções (try/catch) e evitar a repetição de código em cada handler.2.2.2 A Camada de Serviço (core/)Esta camada encapsula os Casos de Uso (Use Cases). É onde as regras de negócio residem. Diferente de frameworks como NestJS que impõem injeção de dependência pesada, no WUZAPI Manager optamos por uma Injeção de Dependência Manual ou Leve.4Diretriz: Services devem ser agnósticos ao framework web (Express). Eles recebem dados tipados e retornam dados tipados ou erros de domínio.Padrão de Result: Em vez de lançar erros (throw new Error), que são caros em termos de performance e fluxo de controle, recomenda-se o uso do padrão Result ou Either (monads), onde o serviço retorna um objeto indicando sucesso ou falha. Isso torna o tratamento de erros explícito e tipado.2.2.3 A Camada de Repositório (infra/)A camada de repositório abstrai a persistência. Com o SQLite, esta camada é crucial para isolar as queries SQL (ou chamadas de Query Builder).Diretriz: O repositório deve retornar Entidades de Domínio, não linhas cruas do banco de dados. Para isso, utilizamos Mappers que convertem o formato do banco (snake_case, tipos primitivos) para objetos de domínio ricos (camelCase, Value Objects).2.3 Documentação de API Automática (OpenAPI/Swagger)Manter arquivos YAML do Swagger manualmente é propenso a erros e desatualização. A prática recomendada para 2025 é a geração de especificações Code-First.Ferramenta Recomendada: tsoa (TypeScript OpenAPI).14O tsoa analisa as classes TypeScript dos Controllers e as interfaces de DTO para gerar automaticamente:A especificação swagger.json compatível com OpenAPI 3.0.As rotas do Express, incluindo validação de tipos em tempo de execução.Fluxo de Trabalho:O desenvolvedor anota o Controller com decoradores @Route, @Get, @Post.O comando tsoa spec-and-routes é executado durante o build.O frontend gera seus clientes API automaticamente baseando-se no swagger.json gerado, garantindo sincronia total.3. Persistência de Dados: Otimização SQLite em ProduçãoO uso do SQLite em um ambiente de produção Node.js desafia o status quo, mas com a configuração correta, oferece latência de consulta inferior a 1ms e complexidade operacional reduzida. No entanto, o SQLite "out-of-the-box" não é adequado para alta concorrência. É necessário aplicar configurações específicas de "harderning".3.1 Seleção do Driver: better-sqlite3A pesquisa aponta inequivocamente para o uso da biblioteca better-sqlite3 em detrimento da sqlite3 ou sqlite padrão do Node.16Motivação: O better-sqlite3 é síncrono. Embora "síncrono" seja geralmente um anátema em Node.js, para operações de banco de dados SQLite (que são chamadas de sistema I/O extremamente rápidas), a sobrecarga de alternância de contexto do Event Loop assíncrono é maior que o tempo da própria operação. A abordagem síncrona simplifica o código e aumenta drasticamente o throughput (operações por segundo).3.2 Modo WAL (Write-Ahead Logging)A configuração mais crítica para o WUZAPI Manager é a ativação do modo WAL.6O Problema: No modo padrão (Rollback Journal), uma escrita bloqueia todo o banco de dados para leitura e escrita.A Solução WAL: As alterações são escritas em um arquivo separado (.wal), permitindo que leitores e escritores operem simultaneamente. Isso é essencial para uma aplicação multi-usuário como o WUZAPI.Implementação Obrigatória:O arquivo de inicialização do banco de dados (src/shared/infra/database.ts) deve executar os seguintes PRAGMAs imediatamente após a conexão:TypeScriptimport Database from 'better-sqlite3';

const db = new Database('wuzapi.db');

// Otimizações Críticas de Performance e Concorrência
db.pragma('journal_mode = WAL'); // Habilita concorrência Leitura/Escrita
db.pragma('synchronous = NORMAL'); // Reduz fsyncs, seguro o suficiente com WAL
db.pragma('busy_timeout = 5000'); // Aguarda 5s em caso de bloqueio antes de falhar
db.pragma('foreign_keys = ON'); // Garante integridade referencial
db.pragma('cache_size = -20000'); // Usa ~20MB de RAM para cache de páginas
Esta configuração transforma o SQLite de um banco de dados "embarcado" em um motor de persistência capaz de lidar com centenas de requisições por segundo em um único nó.193.3 Estratégia de Acesso a DadosPara manter a tipagem forte sem o "peso" de um ORM completo como o Prisma (que pode adicionar latência de inicialização), recomenda-se o uso do Kysely 1 como Query Builder. O Kysely fornece segurança de tipos total baseada na introspecção do banco, mas gera SQL otimizado e utiliza o driver better-sqlite3 por baixo dos panos, alinhando-se com a filosofia de "Explicitude sobre Implicitude".4. Arquitetura de Frontend: Feature-Sliced Design (FSD)Para o frontend em React, abandonamos a estrutura tradicional (components/, containers/, pages/) e o Atomic Design, que frequentemente falham em escalar com a complexidade das regras de negócio. Adotamos o Feature-Sliced Design (FSD), uma metodologia arquitetural que organiza o código por escopo de negócio e complexidade técnica.204.1 A Hierarquia de Camadas (Layers)O FSD impõe uma disciplina rigorosa de dependências unidirecionais. Uma camada só pode importar módulos de camadas estritamente inferiores. A estrutura, do nível mais alto para o mais baixo, é detalhada na tabela a seguir:CamadaPropósitoConteúdo TípicoPode Importar Deapp/InicializaçãoProviders (Redux, Theme), Router, CSS Global.Todas as camadas abaixo.pages/Composição de RotasComponentes que representam rotas completas (e.g., LoginPage).Widgets, Features, Entities, Shared.widgets/Blocos de UI ComplexosBlocos autônomos que combinam features (e.g., Header, InstanceList).Features, Entities, Shared.features/Casos de UsoInterações do usuário com valor de negócio (e.g., AuthByPhone, SendMessage).Entities, Shared.entities/Modelagem de NegócioVisualização de dados de negócio (e.g., UserCard, InstanceStatus).Shared.shared/Código ReutilizávelUI Kit (Shadcn), API clients, helpers, hooks genéricos.Nenhuma (camada base).4.2 Anatomia de uma Slice e SegmentosDentro de cada camada (exceto shared e app), o código é agrupado em Slices (Fatias) baseadas no domínio (ex: user, instance, chat). Dentro de cada Slice, o código é dividido em Segmentos técnicos.22Exemplo Prático: src/features/connect-instanceui/: Componentes React da feature (ex: QRCodeScanner.tsx, ConnectButton.tsx).model/: Lógica de estado (ex: hooks do React Query, stores do Zustand, reducers).api/: Chamadas de API específicas para esta feature (ex: connectInstanceApi.ts).lib/: Funções auxiliares exclusivas desta feature.index.ts: API Pública da feature. Apenas o que é exportado aqui pode ser usado por widgets ou pages.4.3 Integração com Shadcn/UI e a Camada SharedO Shadcn/UI 24 se encaixa perfeitamente na camada shared/ui. Como o Shadcn não é uma biblioteca de componentes tradicional (é código que você copia e cola), esses componentes residem em src/shared/ui/ e são tratados como primitivos do projeto.Regra de Ouro: Componentes em shared/ui (como Button, Input, Dialog) devem ser "burros". Eles nunca devem conter lógica de negócio ou importar de entities ou features. Se um botão precisa de lógica de negócio (ex: "Botão que só ativa se a Instância estiver desconectada"), deve-se criar um componente novo em features ou entities que compõe o botão primitivo do shared.4.4 Gerenciamento de Estado: Separação Cliente/ServidorO manual prescreve uma separação clara de responsabilidades de estado 26:Server State (Estado do Servidor): Gerenciado via TanStack Query (React Query). Localizado nos segmentos api/ ou model/ das entities e features. Responsável por cache, deduplicação e estados de carregamento.Client State (Estado do Cliente): Gerenciado via Zustand ou Context API. Localizado nos segmentos model/. Responsável por estados efêmeros de UI (modais abertos, filtros ativos, inputs de formulário). O Redux é considerado verboso demais para este stack, a menos que a complexidade de estado seja extrema.5. Infraestrutura e Orquestração: Docker SwarmA implantação do WUZAPI Manager em Docker Swarm exige atenção especial devido à natureza do SQLite. Ao contrário de bancos de dados cliente-servidor (PostgreSQL, MySQL), o SQLite depende de bloqueios de arquivo (file locks) que não funcionam corretamente em sistemas de arquivos de rede (NFS, GlusterFS) comuns em clusters, podendo levar à corrupção do banco (database disk image is malformed).275.1 O Paradoxo da Persistência e a Solução de PinningPara garantir a integridade dos dados, devemos aplicar o padrão de Node Pinning (Fixação de Nó). O serviço de backend deve ser restringido a rodar em um nó específico do cluster Swarm, onde o arquivo do banco de dados reside fisicamente.Configuração do Docker Compose (Stack):YAMLversion: '3.9'

services:
  backend:
    image: wuzapi/backend:latest
    deploy:
      mode: replicated
      replicas: 1 # O SQLite no modo WAL suporta apenas um escritor. Escala horizontal de escrita não é possível.
      placement:
        constraints:
          # Restrição Crítica: O serviço só pode rodar no nó rotulado como 'wuzapi-db-node'
          - node.labels.wuzapi.data == true
      restart_policy:
        condition: on-failure
    volumes:
      # Uso de Bind Mount para performance nativa de I/O e suporte a locking
      - type: bind
        source: /var/lib/wuzapi/data
        target: /app/data
    environment:
      - DB_PATH=/app/data/wuzapi.db

  frontend:
    image: wuzapi/frontend:latest
    deploy:
      mode: replicated
      replicas: 2 # O frontend é stateless e pode escalar livremente
      placement:
        constraints:
          - node.role == worker
5.2 Volumes vs. Bind MountsA pesquisa indica que Bind Mounts são preferíveis a Volumes Docker nomeados para este caso de uso específico com SQLite em Swarm.29Motivo: Bind Mounts oferecem visibilidade direta do sistema de arquivos do host, facilitando backups via cron jobs no host e garantindo que o driver de sistema de arquivos subjacente suporte as chamadas fcntl() necessárias para o travamento de arquivo do SQLite.5.3 Estratégia de Backup e Recuperação (Litestream)Como dependemos de um único nó para persistência, o risco de perda de dados se esse nó falhar fisicamente é alto. Para mitigar isso, recomenda-se o uso do Litestream como um processo "sidecar" no contêiner ou no host. O Litestream replica os frames do WAL do SQLite continuamente para um armazenamento de objetos (como S3 ou MinIO), proporcionando um RPO (Recovery Point Objective) de segundos, sem a complexidade de gerenciar um cluster de banco de dados distribuído.6. Diretrizes de Qualidade, Segurança e Manutenção6.1 Linting e Formatação (Padrão 2025)A configuração de linting deve migrar para o novo ESLint Flat Config (eslint.config.js), abandonando o formato legado .eslintrc.32Stack de Qualidade:ESLint: Focado em identificar erros lógicos e más práticas.Prettier: Focado exclusivamente na formatação estética.Plugins Essenciais:@typescript-eslint/recommended-type-checked: Utiliza a informação de tipos para regras mais inteligentes (ex: previne promessas "flutuantes" não aguardadas).9eslint-plugin-import: Para forçar as regras de fronteira do Feature-Sliced Design (impedir que shared importe features).Configuração TypeScript (tsconfig.json):O modo estrito é inegociável.JSON{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext", // Melhores práticas para Node moderno
    "strict": true,       // Habilita strictNullChecks, noImplicitAny, etc.
    "noUncheckedIndexedAccess": true // Previne erros de acesso a arrays/objetos
  }
}
6.2 Estratégia de TestesPara maximizar a performance da pipeline de CI, substituímos o Jest pelo Vitest.34 O Vitest compartilha a configuração do Vite, eliminando a complexidade de transformar TypeScript/JSX separadamente para testes.Testes Unitários (Backend): Foco na Camada de Serviço (core/). Mockamos os repositórios para testar a lógica de negócio pura em isolamento.Testes de Integração (Backend): Utilizam um banco SQLite em memória (:memory:) ou temporário no disco. Graças à velocidade do SQLite, é possível rodar centenas de testes de integração (que fazem chamadas HTTP reais via supertest e tocam no banco) em segundos.Testes de Componente (Frontend): Focados nas Camadas de features e widgets usando React Testing Library. Testamos o comportamento do usuário (cliques, inputs), não a implementação interna.6.3 Segurança em ProfundidadeA segurança deve ser implementada em camadas (Defense in Depth).36Middleware de Segurança (Express):Helmet: Obrigatório para definir headers de segurança (HSTS, Content-Security-Policy).Rate Limiting: Uso do express-rate-limit para mitigar ataques de força bruta e DoS na camada de aplicação. Recomenda-se configurar limites distintos para rotas de autenticação (mais estritos) e rotas de API gerais.Sanitização de Entrada: Embora o Zod garanta a tipagem, ele deve ser configurado com .strict() para rejeitar campos desconhecidos no corpo da requisição, prevenindo ataques de Mass Assignment (atribuição em massa) onde um atacante tenta injetar campos como isAdmin: true.Segurança de Imagem Docker: As imagens devem ser baseadas em versões alpine ou slim do Node.js para reduzir a superfície de ataque, e o usuário dentro do contêiner deve ser não-privilegiado (USER node), nunca root.6.4 Manutenção e OnboardingPara facilitar a entrada de novos desenvolvedores, o projeto deve incluir:docker-compose.dev.yml: Um ambiente de desenvolvimento "one-click" que sobe o backend (com hot-reload), frontend e ferramentas de visualização de banco (como o adminer ou similar para SQLite).VS Code Extensions Pack (.vscode/extensions.json): Recomendação automática de extensões como ESLint, Prettier, e visualizadores de SQLite.Arquitetura de Decisão (ADR): Manter uma pasta docs/adr registrando decisões arquiteturais importantes (ex: "Por que escolhemos SQLite e não Postgres", "Por que FSD"). Isso fornece contexto histórico vital para a manutenção futura.7. ConclusãoEste manual estabelece o WUZAPI Manager como um projeto de engenharia madura e moderna. Ao adotar o Monólito Modular e o Feature-Sliced Design, garantimos que a complexidade do código cresça de forma linear, não exponencial. Ao abraçar as restrições e capacidades do SQLite com WAL, eliminamos a sobrecarga operacional de bancos distribuídos sem sacrificar a performance. A conformidade rigorosa com estas diretrizes resultará em um sistema que é não apenas funcional, mas um prazer de desenvolver, testar e manter. A excelência técnica aqui descrita não é um destino, mas uma prática diária que deve ser cultivada por toda a equipe.